import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class GigService {
  private readonly logger = new Logger(GigService.name);
  constructor(private prisma: PrismaService) {}

  // ─── Market Data (master schema) ─────────────────────────────────
  async getSectors() {
    return this.prisma.$queryRaw`
      SELECT sectorid, sector, code
      FROM master.sector
      WHERE is_active = true
      ORDER BY sort_order, sector
    `;
  }

  async getFieldsBySector(sectorid: number) {
    return this.prisma.$queryRaw`
      SELECT fieldid, field, sectorid, code
      FROM master.field
      WHERE sectorid = ${sectorid} AND is_active = true
      ORDER BY sort_order, field
    `;
  }

  async getMarketById(marketid: number) {
    const rows: any[] = await this.prisma.$queryRaw`
      SELECT m.marketid, m.sectorid, m.fieldid, m.p_s_ps, m.item, m.delivery_mode,
        s.sector, f.field
      FROM master.market m
      LEFT JOIN master.sector s ON s.sectorid = m.sectorid
      LEFT JOIN master.field f ON f.fieldid = m.fieldid
      WHERE m.marketid = ${marketid}
    `;
    return rows[0] || null;
  }

  async getMarketItems(sectorid: number, fieldid: number, p_s_ps?: string) {
    if (p_s_ps) {
      return this.prisma.$queryRaw`
        SELECT marketid, sectorid, fieldid, p_s_ps, item, delivery_mode, code
        FROM master.market
        WHERE sectorid = ${sectorid}
          AND fieldid = ${fieldid}
          AND p_s_ps = ${p_s_ps}
          AND is_active = true
        ORDER BY sort_order, item
      `;
    }
    return this.prisma.$queryRaw`
      SELECT marketid, sectorid, fieldid, p_s_ps, item, delivery_mode, code
      FROM master.market
      WHERE sectorid = ${sectorid}
        AND fieldid = ${fieldid}
        AND is_active = true
      ORDER BY sort_order, item
    `;
  }

  // Get distinct p_s_ps values for a sector+field combo
  async getProductServiceOptions(sectorid: number, fieldid: number) {
    return this.prisma.$queryRaw`
      SELECT DISTINCT p_s_ps
      FROM master.market
      WHERE sectorid = ${sectorid}
        AND fieldid = ${fieldid}
        AND is_active = true
      ORDER BY p_s_ps
    `;
  }

  // ─── Requirements CRUD ───────────────────────────────────────────
  async getRequirements(userid?: bigint) {
    if (userid) {
      return this.prisma.requirement.findMany({ where: { userid }, orderBy: { created_at: 'desc' } });
    }
    return this.prisma.requirement.findMany({ orderBy: { created_at: 'desc' } });
  }

  async getRequirementById(requirid: bigint) {
    return this.prisma.requirement.findUnique({ where: { requirid } });
  }

  async createRequirement(data: {
    userid: bigint;
    marketid: number;
    delivery_mode?: string;
    requirements?: string;
    eligibility?: string;
    doc_url?: string;
    audio_url?: string;
    video_url?: string;
    budget?: number;
    escrow?: number;
    bidate?: Date;
    delivdate?: Date;
  }) {
    return this.prisma.requirement.create({ data });
  }

  async updateRequirement(requirid: bigint, data: any) {
    return this.prisma.requirement.update({ where: { requirid }, data });
  }

  async deleteRequirement(requirid: bigint) {
    return this.prisma.requirement.delete({ where: { requirid } });
  }

  // ─── Offerings CRUD ──────────────────────────────────────────────
  async getOfferings(userid?: bigint) {
    if (userid) {
      return this.prisma.offering.findMany({ where: { userid }, orderBy: { created_at: 'desc' } });
    }
    return this.prisma.offering.findMany({ orderBy: { created_at: 'desc' } });
  }

  async createOffering(data: any) {
    return this.prisma.offering.create({ data });
  }

  async updateOffering(offerid: bigint, data: any) {
    return this.prisma.offering.update({ where: { offerid }, data });
  }

  async deleteOffering(offerid: bigint) {
    return this.prisma.offering.delete({ where: { offerid } });
  }

  // ─── Bids CRUD ───────────────────────────────────────────────────
  async getBids(requirid?: bigint) {
    if (requirid) {
      return this.prisma.bid.findMany({ where: { requirid }, orderBy: { created_at: 'desc' } });
    }
    return this.prisma.bid.findMany({ orderBy: { created_at: 'desc' } });
  }

  async createBid(data: any) {
    return this.prisma.bid.create({ data });
  }

  async updateBid(bidid: bigint, data: any) {
    return this.prisma.bid.update({ where: { bidid }, data });
  }

  async deleteBid(bidid: bigint) {
    return this.prisma.bid.delete({ where: { bidid } });
  }

  // ─── Agreements CRUD ─────────────────────────────────────────────
  async getAgreements(bidid?: bigint) {
    if (bidid) {
      return this.prisma.bidAgree.findMany({ where: { bidid }, orderBy: { created_at: 'desc' } });
    }
    return this.prisma.bidAgree.findMany({ orderBy: { created_at: 'desc' } });
  }

  async createAgreement(data: any) {
    return this.prisma.bidAgree.create({ data });
  }

  async updateAgreement(agreeid: bigint, data: any) {
    return this.prisma.bidAgree.update({ where: { agreeid }, data });
  }

  async deleteAgreement(agreeid: bigint) {
    return this.prisma.bidAgree.delete({ where: { agreeid } });
  }

  // ─── Dashboard Enriched Queries ──────────────────────────────────
  async getRequirementsEnriched() {
    return this.prisma.$queryRaw`
      SELECT
        r.requirid, r.userid, r.marketid, r.delivery_mode,
        r.requirements, r.eligibility,
        r.doc_url, r.audio_url, r.video_url,
        r.budget, r.escrow, r.bidate, r.delivdate,
        r.created_at,
        m.item AS market_item,
        m.p_s_ps,
        s.sector AS sector_name,
        f.field AS field_name,
        u.fname, u.lname, u.pic, u.verified,
        co.country AS country_name,
        st.state AS state_name,
        d.district AS district_name,
        u.pincode,
        pl.place AS place_name,
        (SELECT COUNT(*) FROM public.bid b WHERE b.requirid = r.requirid) AS bid_count
      FROM public.requirements r
      LEFT JOIN master.market m ON m.marketid = r.marketid
      LEFT JOIN master.sector s ON s.sectorid = m.sectorid
      LEFT JOIN master.field f ON f.fieldid = m.fieldid
      LEFT JOIN public."user" u ON u.userid = r.userid
      LEFT JOIN master.country co ON co.country_code = u.country_code
      LEFT JOIN master.state st ON st.stateid = u.stateid
      LEFT JOIN master.district d ON d.districtid = u.districtid
      LEFT JOIN master.place pl ON pl.placeid = u.placeid
      ORDER BY r.created_at DESC
    `;
  }

  async getOfferingsEnriched() {
    return this.prisma.$queryRaw`
      SELECT
        o.offerid, o.userid, o.marketid, o.delivery_mode,
        o.offerings,
        o.doc_url, o.audio_url, o.video_url,
        o.created_at, o.updated_at,
        m.item AS market_item,
        m.p_s_ps,
        s.sector AS sector_name,
        f.field AS field_name,
        u.fname, u.lname, u.pic, u.verified,
        co.country AS country_name,
        st.state AS state_name,
        d.district AS district_name,
        u.pincode,
        pl.place AS place_name
      FROM public.offerings o
      LEFT JOIN master.market m ON m.marketid = o.marketid
      LEFT JOIN master.sector s ON s.sectorid = m.sectorid
      LEFT JOIN master.field f ON f.fieldid = m.fieldid
      LEFT JOIN public."user" u ON u.userid = o.userid
      LEFT JOIN master.country co ON co.country_code = u.country_code
      LEFT JOIN master.state st ON st.stateid = u.stateid
      LEFT JOIN master.district d ON d.districtid = u.districtid
      LEFT JOIN master.place pl ON pl.placeid = u.placeid
      ORDER BY o.created_at DESC
    `;
  }

  // ─── Location Data (master schema) ───────────────────────────────
  async getCountries() {
    return this.prisma.$queryRaw`
      SELECT country_code, country, flag
      FROM master.country
      ORDER BY country
    `;
  }

  async getStatesByCountry(country_code: string) {
    return this.prisma.$queryRaw`
      SELECT stateid, state, state_code
      FROM master.state
      WHERE country_code = ${country_code}
      ORDER BY state
    `;
  }

  async getDistrictsByState(stateid: number) {
    return this.prisma.$queryRaw`
      SELECT districtid, district
      FROM master.district
      WHERE stateid = ${stateid}
      ORDER BY district
    `;
  }

  async getPostalsByDistrict(districtid: number) {
    return this.prisma.$queryRaw`
      SELECT postid, pincode, postoffice
      FROM master.postal
      WHERE districtid = ${districtid}
      ORDER BY pincode
    `;
  }

  async getPlacesByPincode(pincode: string) {
    return this.prisma.$queryRaw`
      SELECT placeid, place
      FROM master.place
      WHERE pincode = ${pincode}
      ORDER BY place
    `;
  }


  // ─── Call Service (Tata Smartflo + API Dialplan) ────────────────
  async initiateCall(callerId: bigint, receiverId: bigint, requirid?: bigint, offerid?: bigint) {
    const caller: any[] = await this.prisma.$queryRaw`
      SELECT userid, phone, whatsapp FROM public."user" WHERE userid = ${callerId}
    `;
    const receiver: any[] = await this.prisma.$queryRaw`
      SELECT userid, phone, whatsapp FROM public."user" WHERE userid = ${receiverId}
    `;
    if (!caller[0] || !receiver[0]) throw new Error('User not found');

    const callerPhone = caller[0].phone || caller[0].whatsapp;
    const receiverPhone = receiver[0].phone || receiver[0].whatsapp;
    if (!callerPhone || !receiverPhone) throw new Error('Phone number missing');

    // Store destination in Redis (caller→receiver mapping, 5 min TTL)
    const Redis = require('ioredis');
    const redis = new Redis({ host: '127.0.0.1', port: 6379, password: 'Red1sSecure2026' });

    // Store with multiple key formats to handle number variations
    const cleanCaller = callerPhone.replace(/^91/, '');
    const fullCaller = callerPhone.startsWith('91') ? callerPhone : '91' + callerPhone;
    await redis.setex('call_dest:' + callerPhone, 300, receiverPhone);
    await redis.setex('call_dest:' + cleanCaller, 300, receiverPhone);
    await redis.setex('call_dest:' + fullCaller, 300, receiverPhone);
    await redis.disconnect();

    // Call Smartflo click_to_call_support (calls the caller first)
    const TATA_API = 'https://api-smartflo.tatateleservices.com/v1/click_to_call_support';
    const TATA_TOKEN = process.env.TATA_SMARTFLO_TOKEN || 'd0e215dd-883e-4f83-ab7e-50a34fee61cf';

    const params = new URLSearchParams();
    params.append('api_key', TATA_TOKEN);
    params.append('customer_number', fullCaller);

    const response = await fetch(TATA_API, {
      method: 'POST',
      body: params,
    });

    const result = await response.json();

    // Log the call
    await this.prisma.$queryRaw`
      INSERT INTO public.call_log (caller_id, receiver_id, requirid, offerid, caller_phone, receiver_phone, status, provider_ref)
      VALUES (${callerId}, ${receiverId}, ${requirid || null}, ${offerid || null}, ${callerPhone}, ${receiverPhone}, 'initiated', ${JSON.stringify(result)})
    `;

    return { success: response.ok, callerPhone, receiverPhone, provider_response: result };
  }

  async handleDialplan(body: any, query: any) {
    // Smartflo sends caller info - find the destination from Redis
    const from = body.call_t_number || body.call_to_number || body.caller_id_number || body.from || query.from || '';
    this.logger.log('[DIALPLAN] Looking up destination for: ' + from);

    const Redis = require('ioredis');
    const redis = new Redis({ host: '127.0.0.1', port: 6379, password: 'Red1sSecure2026' });

    try {
      const cleanFrom = from.replace(/^\+/, '').replace(/^91/, '');
      const fullFrom = from.replace(/^\+/, '');

      // Try multiple key formats
      let dest = await redis.get('call_dest:' + from);
      if (!dest) dest = await redis.get('call_dest:' + cleanFrom);
      if (!dest) dest = await redis.get('call_dest:' + fullFrom);
      if (!dest) dest = await redis.get('call_dest:91' + cleanFrom);

      await redis.disconnect();

      if (dest) {
        const cleanDest = dest.replace(/^\+?91/, '');
        this.logger.log('[DIALPLAN] Transferring ' + from + ' -> ' + cleanDest + ' (raw: ' + dest + ')');
        return [{ transfer: { type: 'number', data: [cleanDest] } }];
      }

      this.logger.log('[DIALPLAN] No destination found for: ' + from);
      return [{ recording: { type: 'system', data: 1234 } }];
    } catch (e) {
      this.logger.error('[DIALPLAN] Error: ' + e);
      await redis.disconnect();
      return [{ recording: { type: 'system', data: 1234 } }];
    }
  }

  async getCallLogs(userid: bigint) {
    return this.prisma.$queryRaw`
      SELECT c.*,
        u1.fname AS caller_name, u2.fname AS receiver_name
      FROM public.call_log c
      LEFT JOIN public."user" u1 ON u1.userid = c.caller_id
      LEFT JOIN public."user" u2 ON u2.userid = c.receiver_id
      WHERE c.caller_id = ${userid} OR c.receiver_id = ${userid}
      ORDER BY c.created_at DESC
    `;
  }
}
