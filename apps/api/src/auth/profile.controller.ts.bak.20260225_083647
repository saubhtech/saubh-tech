import {
  Controller,
  Get,
  Patch,
  Post,
  Body,
  Req,
  UseGuards,
  UseInterceptors,
  UploadedFile,
  HttpCode,
  HttpStatus,
  BadRequestException,
  NotFoundException,
  Logger,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { PrismaService } from '../prisma/prisma.service';
import { JwtAuthGuard } from './jwt-auth.guard';
import { firstValueFrom } from 'rxjs';
import * as fs from 'fs';
import * as path from 'path';
import * as nodemailer from 'nodemailer';
import Redis from 'ioredis';

const UPLOAD_DIR = '/data/uploads/profiles';

/**
 * Profile Controller — GET and PATCH for user profile completion.
 *
 * GET  /api/auth/profile       → fetch user + isComplete + verification status
 * PATCH /api/auth/profile      → partial update (enforces email/phone verified via OTP)
 * POST /api/auth/profile/photo → upload profile photo
 * POST /api/auth/profile/send-otp   → send OTP (email via SMTP, mobile via Evolution API)
 * POST /api/auth/profile/verify-otp → verify OTP and mark as verified
 *
 * All endpoints require JWT (JwtAuthGuard).
 */
@Controller('auth/profile')
@UseGuards(JwtAuthGuard)
export class ProfileController {
  private readonly logger = new Logger(ProfileController.name);
  private redis: Redis;
  private mailer: nodemailer.Transporter | null = null;

  constructor(
    private readonly prisma: PrismaService,
    private readonly config: ConfigService,
    private readonly http: HttpService,
  ) {
    // Redis
    this.redis = new Redis({
      host: process.env.REDIS_HOST || '127.0.0.1',
      port: parseInt(process.env.REDIS_PORT || '6379', 10),
      password: process.env.REDIS_PASSWORD || undefined,
      lazyConnect: true,
    });
    this.redis.connect().catch((err) =>
      this.logger.error('Redis connection failed for ProfileController', err),
    );

    // Nodemailer SMTP transport
    const smtpHost = this.config.get<string>('SMTP_HOST', '');
    if (smtpHost) {
      this.mailer = nodemailer.createTransport({
        host: smtpHost,
        port: parseInt(this.config.get<string>('SMTP_PORT', '587'), 10),
        secure: this.config.get<string>('SMTP_PORT', '587') === '465',
        auth: {
          user: this.config.get<string>('SMTP_USER', ''),
          pass: this.config.get<string>('SMTP_PASS', ''),
        },
      });
      this.mailer.verify().then(() => {
        this.logger.log('SMTP transport ready for email OTP');
      }).catch((err) => {
        this.logger.error('SMTP transport verification failed', err);
      });
    } else {
      this.logger.warn('SMTP_HOST not configured — email OTP will not work');
    }
  }

  // ─── GET /api/auth/profile ──────────────────────────────────────────────

  @Get()
  async getProfile(@Req() req: any) {
    const userid = BigInt(req.user.sub);

    const user = await this.prisma.user.findUnique({
      where: { userid },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    // Check Redis for verification status
    const emailVerified = await this.isFieldVerified(req.user.sub, 'email', user.email);
    const phoneVerified = await this.isFieldVerified(req.user.sub, 'mobile', user.phone);

    return {
      success: true,
      user: this.serializeUser(user),
      isComplete: this.checkComplete(user) && emailVerified && phoneVerified,
      emailVerified,
      phoneVerified,
    };
  }

  // ─── PATCH /api/auth/profile ────────────────────────────────────────────

  @Patch()
  @HttpCode(HttpStatus.OK)
  async updateProfile(@Req() req: any, @Body() body: any) {
    const userid = BigInt(req.user.sub);

    const existing = await this.prisma.user.findUnique({
      where: { userid },
    });

    if (!existing) {
      throw new NotFoundException('User not found');
    }

    // Build update data — only include fields that are provided
    const data: Record<string, any> = {};

    // String fields
    if (body.fname !== undefined) data.fname = String(body.fname).trim();
    if (body.lname !== undefined) data.lname = String(body.lname).trim();
    if (body.qualification !== undefined)
      data.qualification = body.qualification ? String(body.qualification).trim() : null;
    if (body.experience !== undefined)
      data.experience = body.experience ? String(body.experience).trim() : null;
    if (body.pincode !== undefined)
      data.pincode = body.pincode ? String(body.pincode).trim() : null;
    if (body.countryCode !== undefined)
      data.countryCode = body.countryCode ? String(body.countryCode).trim().toUpperCase() : null;

    // UserType: BO, CL, GW, SA, AD
    if (body.usertype !== undefined) {
      const validTypes = ['BO', 'CL', 'GW', 'SA', 'AD'];
      if (body.usertype && !validTypes.includes(body.usertype)) {
        throw new BadRequestException(
          `Invalid usertype "${body.usertype}". Must be one of: BO, CL, GW.`,
        );
      }
      data.usertype = body.usertype || 'GW';
    }

    // Gender enum: M, F, T, O
    if (body.gender !== undefined) {
      const validGenders = ['M', 'F', 'T', 'O'];
      if (body.gender && !validGenders.includes(body.gender)) {
        throw new BadRequestException(
          `Invalid gender "${body.gender}". Must be one of: M, F, T, O.`,
        );
      }
      data.gender = body.gender || null;
    }

    // Date of birth
    if (body.dob !== undefined) {
      if (body.dob) {
        const parsed = new Date(body.dob);
        if (isNaN(parsed.getTime())) {
          throw new BadRequestException('Invalid date of birth format.');
        }
        data.dob = parsed;
      } else {
        data.dob = null;
      }
    }

    // Language IDs
    if (body.langid !== undefined) {
      if (!Array.isArray(body.langid)) {
        throw new BadRequestException('langid must be an array of integers.');
      }
      data.langid = body.langid.map((id: any) => parseInt(id, 10)).filter((n: number) => !isNaN(n));
    }

    // Integer foreign keys
    if (body.stateid !== undefined)
      data.stateid = body.stateid ? parseInt(body.stateid, 10) : null;
    if (body.districtid !== undefined)
      data.districtid = body.districtid ? parseInt(body.districtid, 10) : null;
    if (body.placeid !== undefined)
      data.placeid = body.placeid ? parseInt(body.placeid, 10) : null;

    // ─── Email: only accept if verified via OTP ───────────────────────
    if (body.email !== undefined) {
      const emailVal = body.email ? String(body.email).trim().toLowerCase() : null;
      if (emailVal) {
        // Email verification is checked for isComplete, but saving is allowed without it
        // This lets users save progress even if email verification is delayed
      }
      data.email = emailVal;
    }

    // ─── Phone: only accept if verified via OTP ───────────────────────
    if (body.phone !== undefined) {
      const phoneVal = body.phone ? String(body.phone).trim() : null;
      if (phoneVal) {
        // Phone verification is checked for isComplete, but saving is allowed without it
        // This lets users save progress even if mobile verification is delayed
      }
      data.phone = phoneVal;
    }

    // Prevent empty update
    if (Object.keys(data).length === 0) {
      throw new BadRequestException('No valid fields provided for update.');
    }

    this.logger.log(`Updating profile for user ${userid}: ${Object.keys(data).join(', ')}`);

    const updated = await this.prisma.user.update({
      where: { userid },
      data,
    });

    // Re-check verification for completeness
    const emailVerified = await this.isFieldVerified(req.user.sub, 'email', updated.email);
    const phoneVerified = await this.isFieldVerified(req.user.sub, 'mobile', updated.phone);

    return {
      success: true,
      user: this.serializeUser(updated),
      isComplete: this.checkComplete(updated) && emailVerified && phoneVerified,
      emailVerified,
      phoneVerified,
    };
  }

  // ─── POST /api/auth/profile/photo ───────────────────────────────────────

  @Post('photo')
  @HttpCode(HttpStatus.OK)
  @UseInterceptors(FileInterceptor('photo', {
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: (_req: any, file: any, cb: any) => {
      if (!file.mimetype.startsWith('image/')) {
        return cb(new BadRequestException('Only image files are allowed.'), false);
      }
      cb(null, true);
    },
  }))
  async uploadPhoto(@Req() req: any, @UploadedFile() file: any) {
    if (!file) {
      throw new BadRequestException('No photo file provided.');
    }

    const userid = req.user.sub;
    const ext = path.extname(file.originalname).toLowerCase() || '.jpg';
    const filename = `${userid}${ext}`;
    const filepath = path.join(UPLOAD_DIR, filename);

    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
    fs.writeFileSync(filepath, file.buffer);

    const picUrl = `/uploads/profiles/${filename}`;
    await this.prisma.user.update({
      where: { userid: BigInt(userid) },
      data: { pic: picUrl },
    });

    this.logger.log(`Photo uploaded for user ${userid}: ${picUrl}`);

    return { success: true, pic: picUrl };
  }

  // ─── POST /api/auth/profile/send-otp ─────────────────────────────────────

  @Post('send-otp')
  @HttpCode(HttpStatus.OK)
  async sendProfileOtp(@Req() req: any, @Body() body: any) {
    const userid = req.user.sub;
    const { type, value } = body;

    if (!type || !['mobile', 'email'].includes(type)) {
      throw new BadRequestException('type must be "mobile" or "email".');
    }
    if (!value || !String(value).trim()) {
      throw new BadRequestException('value is required.');
    }

    const redisKey = `otp:profile:${userid}:${type}`;

    if (type === 'mobile') {
      // ─── 4-digit OTP via Evolution API ──────────────────────────────
      const otp = Math.floor(1000 + Math.random() * 9000).toString();
      await this.redis.set(redisKey, otp, 'EX', 300); // 5 min for mobile

      const phone = String(value).trim().replace(/\D/g, '');
      const message = `Your Saubh verification code is: ${otp}\nValid for 2 minutes. Do not share.`;

      // Send directly via Evolution API
      await this.sendViaEvolution(phone, message);

      this.logger.log(`Mobile OTP sent via Evolution to ${phone}`);
      return { success: true, sent: true, expiresIn: 300, digits: 4 };

    } else {
      // ─── 6-digit OTP via Email (SMTP) ───────────────────────────────
      const otp = Math.floor(100000 + Math.random() * 900000).toString();
      await this.redis.set(redisKey, otp, 'EX', 600); // 10 min for email

      const emailTo = String(value).trim().toLowerCase();

      if (!this.mailer) {
        this.logger.error('SMTP not configured — cannot send email OTP');
        throw new BadRequestException('Email service not configured. Contact support.');
      }

      const fromAddr = this.config.get<string>('SMTP_FROM', 'noreply@saubh.tech');

      try {
        await this.mailer.sendMail({
          from: `"Saubh.Tech" <${fromAddr}>`,
          to: emailTo,
          subject: 'Your Saubh.Tech Verification Code',
          html: `
            <div style="font-family:sans-serif;max-width:480px;margin:0 auto;padding:32px;background:#f8f9fa;border-radius:12px;">
              <div style="text-align:center;margin-bottom:24px;">
                <h2 style="color:#15192d;margin:0;">Saubh<span style="color:#7c3aed;">.</span>Tech</h2>
              </div>
              <div style="background:#fff;padding:28px;border-radius:10px;border:1px solid #e5e7eb;">
                <p style="color:#374151;font-size:15px;margin:0 0 16px;">Your verification code is:</p>
                <div style="text-align:center;padding:16px;background:linear-gradient(135deg,#f3f0ff,#ecfdf5);border-radius:10px;margin:0 0 16px;">
                  <span style="font-size:32px;font-weight:800;letter-spacing:8px;color:#7c3aed;">${otp}</span>
                </div>
                <p style="color:#6b7280;font-size:13px;margin:0;">Valid for 5 minutes. Do not share this code.</p>
              </div>
              <p style="color:#9ca3af;font-size:11px;text-align:center;margin:16px 0 0;">
                If you didn't request this, please ignore this email.
              </p>
            </div>
          `,
          text: `Your Saubh.Tech verification code is: ${otp}\nValid for 5 minutes. Do not share.`,
        });

        this.logger.log(`Email OTP sent to ${emailTo}`);
        return { success: true, sent: true, expiresIn: 600, digits: 6 };

      } catch (err: any) {
        this.logger.error(`Failed to send email OTP to ${emailTo}: ${err.message}`);
        throw new BadRequestException('Failed to send verification email. Please try again.');
      }
    }
  }

  // ─── POST /api/auth/profile/verify-otp ───────────────────────────────────

  @Post('verify-otp')
  @HttpCode(HttpStatus.OK)
  async verifyProfileOtp(@Req() req: any, @Body() body: any) {
    const userid = req.user.sub;
    const { type, value, otp } = body;

    if (!type || !['mobile', 'email'].includes(type)) {
      throw new BadRequestException('type must be "mobile" or "email".');
    }
    if (!value || !String(value).trim()) {
      throw new BadRequestException('value is required.');
    }
    if (!otp || !String(otp).trim()) {
      throw new BadRequestException('otp is required.');
    }

    const redisKey = `otp:profile:${userid}:${type}`;
    const stored = await this.redis.get(redisKey);

    if (!stored || stored !== String(otp).trim()) {
      throw new BadRequestException('Invalid or expired OTP.');
    }

    // OTP valid — delete OTP key
    await this.redis.del(redisKey);

    // Mark this value as verified (TTL 24h — lasts for session)
    const cleanValue = type === 'email'
      ? String(value).trim().toLowerCase()
      : String(value).trim().replace(/\D/g, '');
    const verifiedKey = `verified:profile:${userid}:${type}:${cleanValue}`;
    await this.redis.set(verifiedKey, '1', 'EX', 2592000); // 30 days

    // Also update the DB field
    const updateData: Record<string, any> = {};
    if (type === 'mobile') {
      updateData.phone = cleanValue;
    } else {
      updateData.email = cleanValue;
    }

    await this.prisma.user.update({
      where: { userid: BigInt(userid) },
      data: updateData,
    });

    this.logger.log(`Profile ${type} verified for user ${userid}: ${cleanValue}`);

    return { success: true, verified: true };
  }

  // ─── Evolution API direct sender ────────────────────────────────────────

  private async sendViaEvolution(to: string, body: string): Promise<void> {
    const baseUrl = this.config.get<string>('EVOLUTION_API_URL', 'http://localhost:8081');
    const apiKey = this.config.get<string>('EVOLUTION_API_KEY', '');

    // Get instance name from DB or env
    let instance = this.config.get<string>('EVOLUTION_INSTANCE', '');
    try {
      const channel = await this.prisma.waChannel.findFirst({
        where: { type: 'EVOLUTION', isActive: true },
        select: { instanceName: true },
      });
      if (channel?.instanceName) instance = channel.instanceName;
    } catch (err: any) {
      this.logger.warn(`Failed to get Evolution instance from DB: ${err.message}`);
    }

    if (!instance) {
      this.logger.error('No Evolution instance configured for mobile OTP');
      throw new BadRequestException('WhatsApp service not configured. Contact support.');
    }

    try {
      const url = `${baseUrl}/message/sendText/${instance}`;
      await firstValueFrom(
        this.http.post(
          url,
          { number: to, text: body },
          {
            headers: { apikey: apiKey, 'Content-Type': 'application/json' },
            timeout: 10000,
          },
        ),
      );
    } catch (err: any) {
      const errMsg = err?.response?.data?.message || err?.response?.data?.error || err.message;
      this.logger.error(`Evolution API send failed to ${to}: ${errMsg}`);
      throw new BadRequestException('Failed to send WhatsApp OTP. Please try again.');
    }
  }

  // ─── Helpers ────────────────────────────────────────────────────────────

  /**
   * Check if a field value has been verified via OTP.
   */
  private async isFieldVerified(userid: string, type: string, value: string | null): Promise<boolean> {
    if (!value) return false;
    const cleanValue = type === 'email'
      ? value.trim().toLowerCase()
      : value.trim().replace(/\D/g, '');
    const key = `verified:profile:${userid}:${type}:${cleanValue}`;
    const result = await this.redis.get(key);
    return result === '1';
  }

  /**
   * Check if all required profile fields are filled.
   * Note: email/phone verification is checked separately.
   */
  private checkComplete(user: any): boolean {
    return !!(
      user.fname &&
      user.lname &&
      user.email &&
      user.phone &&
      user.pic &&
      user.gender &&
      user.dob &&
      user.langid &&
      user.langid.length > 0 &&
      user.qualification &&
      user.experience &&
      user.usertype &&
      user.countryCode &&
      user.stateid &&
      user.districtid &&
      user.pincode &&
      user.placeid
    );
  }

  private serializeUser(user: any) {
    return {
      userid: user.userid.toString(),
      whatsapp: user.whatsapp,
      fname: user.fname,
      lname: user.lname,
      email: user.email,
      phone: user.phone,
      pic: user.pic,
      gender: user.gender,
      dob: user.dob,
      langid: user.langid,
      qualification: user.qualification,
      experience: user.experience,
      usertype: user.usertype,
      countryCode: user.countryCode,
      stateid: user.stateid,
      districtid: user.districtid,
      pincode: user.pincode,
      placeid: user.placeid ? user.placeid.toString() : null,
      verified: user.verified,
      status: user.status,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }
}
