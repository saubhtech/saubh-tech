'use client';
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  LiveKitRoom,
  RoomAudioRenderer,
  ControlBar,
  useParticipants,
  useRoomContext,
} from '@livekit/components-react';
import '@livekit/components-styles';
import { Track, RoomEvent, LocalParticipant, Participant } from 'livekit-client';

interface CallViewProps {
  roomId: number;
  token: string;
  livekitUrl: string;
  callType?: 'video' | 'audio';
  onClose: () => void;
}

export default function CallView({ roomId, token, livekitUrl, callType = 'video', onClose }: CallViewProps) {
  const [isConnecting, setIsConnecting] = useState(true);
  if (!token || !livekitUrl) return null;

  return (
    <div style={{
      position: 'fixed', inset: 0, zIndex: 9999,
      background: '#0a0a0a', display: 'flex', flexDirection: 'column',
    }}>
      <div style={{
        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
        padding: '12px 20px', background: 'rgba(0,0,0,0.8)', borderBottom: '1px solid #222',
      }}>
        <span style={{ color: '#fff', fontSize: 16, fontWeight: 600 }}>
          {isConnecting ? 'Connecting...' : callType === 'audio' ? 'ðŸŽ¤ Voice Call' : 'ðŸ“¹ Video Call'}
        </span>
        <button onClick={onClose} style={{
          background: '#ef4444', color: '#fff', border: 'none', borderRadius: 8,
          padding: '8px 20px', fontSize: 14, fontWeight: 600, cursor: 'pointer',
        }}>End Call</button>
      </div>
      <div style={{ flex: 1, overflow: 'hidden' }}>
        <LiveKitRoom
          serverUrl={livekitUrl}
          token={token}
          connect={true}
          video={false}
          audio={false}
          onConnected={() => setIsConnecting(false)}
          onDisconnected={() => onClose()}
          onError={(err) => { console.error('LiveKit error:', err); }}
          style={{ height: '100%' }}
          data-lk-theme="default"
        >
          <CallContent callType={callType} onClose={onClose} />
          <RoomAudioRenderer />
        </LiveKitRoom>
      </div>
    </div>
  );
}

function VideoTile({ participant, isLocal }: { participant: Participant; isLocal: boolean }) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [hasVideo, setHasVideo] = useState(false);

  useEffect(() => {
    const el = videoRef.current;
    if (!el) return;

    const attach = () => {
      const camPub = participant.getTrackPublication(Track.Source.Camera);
      const screenPub = participant.getTrackPublication(Track.Source.ScreenShare);
      const pub = camPub?.track ? camPub : screenPub?.track ? screenPub : null;
      if (pub?.track) {
        pub.track.attach(el);
        el.muted = isLocal;
        el.play().catch(() => {});
        setHasVideo(true);
      } else {
        setHasVideo(false);
      }
    };

    attach();
    const interval = setInterval(attach, 500);
    return () => {
      clearInterval(interval);
      const camPub = participant.getTrackPublication(Track.Source.Camera);
      if (camPub?.track && el) camPub.track.detach(el);
    };
  }, [participant, isLocal]);

  return (
    <div style={{
      flex: '1 1 45%', maxWidth: '100%', position: 'relative',
      borderRadius: 12, overflow: 'hidden', background: '#111',
      minHeight: 200, display: 'flex', alignItems: 'center', justifyContent: 'center',
    }}>
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted={isLocal}
        style={{
          width: '100%', height: '100%', objectFit: 'cover',
          display: hasVideo ? 'block' : 'none',
          transform: isLocal ? 'scaleX(-1)' : 'none',
        }}
      />
      {!hasVideo && (
        <div style={{ textAlign: 'center', color: '#555' }}>
          <div style={{ fontSize: 40 }}>ðŸ‘¤</div>
          <div style={{ fontSize: 13, marginTop: 4 }}>
            {isLocal ? 'You' : participant.name || participant.identity}
          </div>
        </div>
      )}
      <div style={{
        position: 'absolute', bottom: 8, left: 8,
        background: 'rgba(0,0,0,0.6)', color: '#fff',
        padding: '2px 8px', borderRadius: 6, fontSize: 12,
      }}>
        {isLocal ? 'You' : participant.name || participant.identity}
      </div>
    </div>
  );
}

function CallContent({ callType, onClose }: { callType: string; onClose: () => void }) {
  const room = useRoomContext();
  const participants = useParticipants();
  const stableOnClose = useCallback(onClose, []);

  useEffect(() => {
    if (!room) return;
    let cancelled = false;

    const enableDevices = async () => {
      // Enable mic
      try {
        await room.localParticipant.setMicrophoneEnabled(true);
        console.log('âœ… Mic enabled');
      } catch (err) { console.warn('Mic failed:', err); }

      if (callType === 'video' && !cancelled) {
        try {
          // Same approach as gig page: enumerate devices, pick real camera
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cameras = devices.filter(d => d.kind === 'videoinput');
          console.log('ðŸ“· Available cameras:', cameras.map(c => c.label));
          const realCam = cameras.find(c => !c.label.toLowerCase().includes('virtual'));

          if (realCam) {
            console.log('ðŸ“· Using camera:', realCam.label, realCam.deviceId);
            await room.localParticipant.setCameraEnabled(true, {
              deviceId: realCam.deviceId,
              resolution: { width: 1280, height: 720, frameRate: 30 },
            } as any);
          } else {
            console.log('ðŸ“· No specific camera found, using default');
            await room.localParticipant.setCameraEnabled(true, {
              facingMode: 'user',
              resolution: { width: 1280, height: 720, frameRate: 30 },
            } as any);
          }
          console.log('âœ… Camera enabled');
        } catch (err) { console.warn('Camera failed:', err); }
      }
    };

    const timer = setTimeout(enableDevices, 800);
    const handleDisconnect = () => stableOnClose();
    room.on(RoomEvent.Disconnected, handleDisconnect);
    return () => {
      cancelled = true;
      clearTimeout(timer);
      room.off(RoomEvent.Disconnected, handleDisconnect);
    };
  }, [room, callType, stableOnClose]);

  return (
    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <div style={{
        position: 'absolute', top: 60, right: 16,
        background: 'rgba(0,0,0,0.7)', color: '#fff',
        padding: '4px 10px', borderRadius: 12, fontSize: 12, zIndex: 10,
      }}>
        {participants.length} in call
      </div>
      <div style={{
        flex: 1, display: 'flex', flexWrap: 'wrap', gap: 8, padding: 8,
        alignItems: 'center', justifyContent: 'center',
      }}>
        {participants.map(p => (
          <VideoTile key={p.identity} participant={p} isLocal={p instanceof LocalParticipant} />
        ))}
      </div>
      <ControlBar
        variation="minimal"
        controls={{ camera: callType === 'video', microphone: true, screenShare: true, leave: true }}
      />
    </div>
  );
}
